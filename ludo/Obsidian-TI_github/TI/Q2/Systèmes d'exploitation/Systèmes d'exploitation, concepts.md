# ordonnancement
## Définition
### Le problème
• Quand doit-on stopper un processus s'exécutant sur un CPU ?  
• Quel processus va continuer sur ce CPU ?  
• Mêmes questions pour les threads d'un processus.  
• Que se passe t’il avec plusieurs processeurs ?
### Les objectifs
✓ Maximiser le taux d'occupation du processeur  
✓ Minimiser le temps de réponse des processus  
Critères d'évaluations de l’ordonnancement :  
• Temps d'attente des processus  
• Débit du processeur  
• Temps de réponse moyen  
• Temps de traitement d'un ensemble de processus
### Les critères d'ordonnancement
Il y aura normalement plusieurs processus dans la file prêt  
Quand le CPU devient disponible, lequel choisir?  
Critères généraux:  
• Bonne utilisation du CPU  
• Réponse rapide à l’usager
Il y a aussi des critères spécifiques d’ordonnancement :  
Utilisation UCT: pourcentage d’utilisation (à maximiser).  
Débit = Throughput: nombre de processus qui s’exécutent complètement dans l’unité  
de temps (à maximiser).  
Temps de rotation = turnaround: le temps pris par le processus de son arrivée à sa  
fin (à minimiser).  
Temps d’attente: attente dans la file prêt (somme de tout le temps passé en file prêt)  
(à minimiser).  
Temps de réponse (pour les systèmes interactifs): le temps entre une demande et la  
réponse (à minimiser).
Nous distinguons deux types d’ordonnancement (concerne l’ordonnancement a court  
terme) :  
• Les mécanismes non-préemptifs qui n’interrompent pas le fonctionnement d’un  
processus : seul l’attente sur une entrée/sortie (qui peut stopper le fonctionnement  
d’un processus) et la fin d’un processus peuvent provoquer l’appel de l’ordonnanceur.  
• Les mécanismes préemptifs qui peuvent interrompre le fonctionnement d’un  
processus ce qui suppose la mise en place d’un timer et des méthodes plus  
complexes de gestion des changements de contexte.
### ordonnanceur et répartiteur
![[Pasted image 20230321125943.png]]
![[Pasted image 20230321130008.png]]
### parallélisme réel et pseudo-parallélisme
![[Pasted image 20230321130037.png]]
## Les mécanismes
### Premier arrivé, premier servi FCFS (ou FIFO) sans ou avec réquisition
#### exemple
![[Pasted image 20230321130235.png]]
#### autre exemple
![[Pasted image 20230321130330.png]]
• Donc dans un sens FCFS favorise les  
processus tributaires du CPU et peut  
conduire à une très mauvaise utilisation des  
ressources tant du CPU que de  
périphériques.  
• Une possibilité: interrompre de temps en  
temps les processus tributaires du CPU pour  
permettre aux autres processus d’exécuter  
(préemption)
### Plus court d'abord
Ce mécanisme consiste à sélectionner le processus nécessitant le moins de temps  
d’exécution (le prochain Burst CPU le plus court). Il existe deux approches :  
• Non-préemptive ; le processus qui prend le contrôle de l’UC ne le quitte qu’à la fin de  
son exécution ou lorsqu’il est bloqué.  
• Préemptive : si un nouveau processus arrive dont la durée prévue est inférieure au  
temps restant d’exécution du processus en cours, ce nouveau processus obtient le  
contrôle du CPU (on parle alors de SRIF, Shortest Remaining Time First)
#### Exemple
![[Pasted image 20230321130423.png]]
![[Pasted image 20230321130445.png]]
![[Pasted image 20230321130502.png]]
#### Exercices 1
![[Pasted image 20230321130631.png]]
![[Pasted image 20230321130645.png]]
#### Exercice 2
![[Pasted image 20230321130719.png]]
![[Pasted image 20230321130730.png]]
![[Pasted image 20230321130745.png]]
![[Pasted image 20230321130757.png]]
![[Pasted image 20230321130809.png]]
![[Pasted image 20230321130822.png]]
![[Pasted image 20230321130833.png]]
![[Pasted image 20230321130843.png]]
### Par priorités constantes
Par priorités constantes  
• chaque processus reçoit une priorité  
• le processus de plus forte priorité est élu  
Avec ou sans réquisition (préemption)
![[Pasted image 20230321130924.png]]
#### Exercice3
![[Pasted image 20230321130948.png]]
![[Pasted image 20230321131002.png]]
### Par priorité : Rate Monotonic
![[Pasted image 20230321131102.png]]
### Par tourniquet (round robin)
• Ce mécanisme est particulièrement utilisé  
dans les systèmes à temps partagé. Le  
planificateur alloue à tour de rôle à chaque  
processus un quota de temps du CPU (10 –  
100 ms).  
• Le processus en cours peut s'interrompre  
pour des raisons internes (ex : accès a un  
périphérique, fin du processus, etc) ou  
parce que le quota de temps alloué s'est  
écoulé. Dans le second cas il est remis  
dans la queue des processus prêts.
#### exemple
![[Pasted image 20230321131130.png]]
#### autre exemple
![[Pasted image 20230321131148.png]]
### Par files de priorités de priorités constantes multiniveaux avec ou sans extinction de priorité
L’ordonnancement  
Les mécanismes  
• Chaque file est associée à un quantum de temps éventuellement différent  
• sans extinction : un processus garde toujours la même priorité  
• avec extinction : la priorité d'un processus décroit en fonction de son utilisation du cpu
![[Pasted image 20230321131303.png]]
![[Pasted image 20230321131323.png]]

### Ordonnancement : système LINUX

![[Pasted image 20230321131424.png]]
## ex de cette partie
![[Système exploit theorie_230310_135602.pdf]]

# gestion de la mémoire
## La fonction de mémorisation
Trois problèmes à résoudre vis-à-vis de la  
mémoire :  
❑Définir un espace d'adressage indépendant  
pour chaque processus  
❑Protéger les espaces d'adressages des processus  
entre eux  
❑Allouer de la mémoire physique à chaque espace  
d'adressage
## Le chargement dynamique en mémoire
![[Pasted image 20230315191402.png]]
![[Pasted image 20230315191426.png]]
## Le découpage de la mémoire
La mémoire centrale peut-être découpée de trois façons :  
◼ la segmentation : les programmes sont découpés en  
parcelles ayant des longueurs variables appelées  
«segments».  
◼ la pagination : elle consiste à diviser la mémoire en  
blocs, et les programmes en pages de longueur fixe.  
◼ une combinaison de segmentation et de pagination :  
certaines parties de la mémoires sont segmentées, les  
autres sont paginées.
## Organisation de la mémoire d’un processus
![[Pasted image 20230315191540.png]]
Le segment de code  
	Le segment de code est obtenu en copiant directement  
	en mémoire le segment de code du fichier exécutable.  
	Au cours de l'exécution du programme, la prochaine  
	instruction à exécuter est repérée par un pointeur  
	d'instruction.
Le segment de données  
	Au dessus du segment de code se trouve le segment  
	de données.  
	Ce segment est traditionnellement composé d'un  
	segment de données initialisées (data), qui est  
	directement copié à partir de l'exécutable, et d'un  
	segment de données non initialisées (bss pour block  
	storage segment) qui est créé dynamiquement.
![[Pasted image 20230315191655.png]]
	Les données initialisées correspondent à toutes les  
	variables globales et statiques initialisées des programmes  
	C. Les données non initialisées correspondent aux  
	variables globales et statiques non initialisées.  
	Le segment de données peut être agrandi ou réduit au  
	cours de l'exécution pour permettre d'y placer des  
	données. Néanmoins, il est habituel de considérer que ce  
	segment est fixe et correspond à celui obtenu avant  
	l'exécution de la première instruction : le segment bss se  
	résume alors aux variables locales de la fonction main().  
	La pile et le tas sont des zones variables.
Les autres informations  
	D'autres informations sont placées dans l'espace mémoire  
	du processus, comme les paramètres passés en ligne lors  
	de l'exécution du programme.  
	Suivant les systèmes d'exploitation, le système peut aussi  
	stocker différents renseignements, comme par exemple le  
	mode dans lequel doit s'exécuter le processus. Ces  
	renseignements se trouvent dans une structure qui se  
	nomme souvent Process Control Bloc (PCB).
Conclusion  
	L'espace mémoire d'un processus est donc divisé en deux  
	morceaux variables situés chacun à une extrémité de  
	l'espace. Ces morceaux sont eux-mêmes divisés en  
	plusieurs segments, certains de taille fixe situés aux  
	extrémités, d'autres de taille variable.  
	Suivant les systèmes d'exploitation, le tas et la pile  
	peuvent se trouver l'un en haut et l'autre en bas, ou  
	l'inverse.
# Organisation de la mémoire physique
## Pagination
La pagination constitue une approche permettant de  
réduire la fragmentation de la mémoire  
(fragmentation externe).  
L’espace des adresses logiques d’un processus est  
‘paginé’ :  
•Les pages sont indépendantes en terme d’adressage à  
l’intérieur de la mémoire et ne sont pas nécessairement  
contiguës  
•Le SE alloue la mémoire physique chaque fois que la  
nécessité de loger une page se présente.
![[Pasted image 20230315192203.png]]
![[Pasted image 20230315192222.png]]
Avantages et inconvénients:  
◼ Meilleure utilisation de la mémoire physique  
(programmes implantés par fragments, dans des pages  
non consécutives).  
◼ Possibilité de ne charger des pages que lorsqu'elles  
sont référencées (chargement à la demande).  
◼ Indépendance de l'espace virtuel et de la mémoire  
physique (mémoire virtuelle généralement plus grande).  
◼ Par contre, fragmentation interne (toutes les  
pages ne sont pas remplies).
## Pagination et Segmentation
![[Pasted image 20230315192255.png]]
## Segmentation
![[Pasted image 20230315192331.png]]
![[Pasted image 20230315192347.png]]
![[Pasted image 20230315192425.png]]
Malheureusement, l’allocations et la  
désallocations successives des segments crée  
également un problème de fragmentation :  
On va alors combiner segmentation et pagination :  
→ paginer les segments
## Segmentation et Pagination
La segmentation et la pagination sont deux notions  
différentes qui sont utilisées conjointement.  
La segmentation doit être vue comme une structuration  
de l'espace des adresses d'un processus, alors que la  
pagination doit être vue comme un moyen d'adaptation  
de la mémoire virtuelle à la mémoire réelle
## Mémoire virtuelle
![[Pasted image 20230315192500.png]]
![[Pasted image 20230315192514.png]]
![[Pasted image 20230315192527.png]]
![[Pasted image 20230315192549.png]]
Bit de validation et défaut de page  
Ne charger que les pages utiles à un instant :  
→ il faut pouvoir tester la présence d'une page en  
mémoire centrale :  
→ rôle du bit de validation  
→ si un processus cherche à accéder à une page non  
présente en mémoire centrale, il se produit un  
déroutement de défaut de page  
	le système d'exploitation lance une entrée/sortie disque  
	pour charger la page en mémoire dans une case libre  
		→ perte de performances !
![[Pasted image 20230315192649.png]]
![[Pasted image 20230315192804.png]]
Les pages d'un processus ne sont chargées en mémoire  
centrale que lorsque le processus y accède  
❑ Lorsqu'un processus accède à une page non présente en  
mémoire centrale, il se produit un défaut de page.  
La page manquante est alors chargée dans une case libre.  
❑Si aucune case n'est libre, le système utilise un algorithme de  
remplacement de page pour choisir une case à libérer.  
❑ L'écroulement est la situation pour laquelle un ou plusieurs  
processus passent plus de temps à paginer qu'à s'exécuter.
# gestion des fichiers

# systèmes de fichiers-add

# systèmes de fichiers-V3

